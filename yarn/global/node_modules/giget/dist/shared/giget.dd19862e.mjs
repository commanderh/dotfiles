import { readFile, writeFile, rm, mkdir } from 'node:fs/promises';
import { homedir } from 'node:os';
import { existsSync, createWriteStream, readdirSync } from 'node:fs';
import { extract } from 'tar';
import { resolve, relative, dirname } from 'pathe';
import { defu } from 'defu';
import { pipeline } from 'node:stream';
import { spawnSync } from 'node:child_process';
import { promisify } from 'node:util';
import fetch$1, { fetch } from 'node-fetch-native';

async function download(url, filePath, opts = {}) {
  const infoPath = filePath + ".json";
  const info = JSON.parse(await readFile(infoPath, "utf8").catch(() => "{}"));
  const headRes = await fetch(url, { method: "HEAD", headers: opts.headers }).catch(() => null);
  const etag = headRes?.headers.get("etag");
  if (info.etag === etag && existsSync(filePath)) {
    return;
  }
  info.etag = etag;
  const res = await fetch(url, { headers: opts.headers });
  if (res.status >= 400) {
    throw new Error(`Failed to download ${url}: ${res.status} ${res.statusText}`);
  }
  const stream = createWriteStream(filePath);
  await promisify(pipeline)(res.body, stream);
  await writeFile(infoPath, JSON.stringify(info), "utf8");
}
const inputRegex = /^(?<repo>[\w.-]+\/[\w.-]+)(?<subdir>[^#]+)?(?<ref>#[\w.-]+)?/;
function parseGitURI(input) {
  const m = input.match(inputRegex)?.groups;
  return {
    repo: m.repo,
    subdir: m.subdir || "/",
    ref: m.ref ? m.ref.substring(1) : "main"
  };
}
function debug(...args) {
  if (process.env.DEBUG) {
    console.debug("[giget]", ...args);
  }
}
function currentShell() {
  if (process.env.SHELL) {
    return process.env.SHELL;
  }
  if (process.platform === "win32") {
    return "cmd.exe";
  }
  return "/bin/bash";
}
function startShell(cwd) {
  cwd = resolve(cwd);
  const shell = currentShell();
  console.info(`(experimental) Opening shell in ${relative(process.cwd(), cwd)}...`);
  spawnSync(shell, [], {
    cwd,
    shell: true,
    stdio: "inherit"
  });
}

const github = (input, opts) => {
  const parsed = parseGitURI(input);
  return {
    name: parsed.repo.replace("/", "-"),
    version: parsed.ref,
    subdir: parsed.subdir,
    headers: { Authorization: opts.auth ? `Bearer ${opts.auth}` : void 0 },
    url: `https://github.com/${parsed.repo}/tree/${parsed.ref}${parsed.subdir}`,
    tar: `https://github.com/${parsed.repo}/archive/${parsed.ref}.tar.gz`
  };
};
const gitlab = (input, opts) => {
  const parsed = parseGitURI(input);
  return {
    name: parsed.repo.replace("/", "-"),
    version: parsed.ref,
    subdir: parsed.subdir,
    headers: { Authorization: opts.auth ? `Bearer ${opts.auth}` : void 0 },
    url: `https://gitlab.com/${parsed.repo}/tree/${parsed.ref}${parsed.subdir}`,
    tar: `https://gitlab.com/${parsed.repo}/-/archive/${parsed.ref}.tar.gz`
  };
};
const bitbucket = (input, opts) => {
  const parsed = parseGitURI(input);
  return {
    name: parsed.repo.replace("/", "-"),
    version: parsed.ref,
    subdir: parsed.subdir,
    headers: { Authorization: opts.auth ? `Bearer ${opts.auth}` : void 0 },
    url: `https://bitbucket.com/${parsed.repo}/src/${parsed.ref}${parsed.subdir}`,
    tar: `https://bitbucket.org/${parsed.repo}/get/${parsed.ref}.tar.gz`
  };
};
const sourcehut = (input, opts) => {
  const parsed = parseGitURI(input);
  return {
    name: parsed.repo.replace("/", "-"),
    version: parsed.ref,
    subdir: parsed.subdir,
    headers: { Authorization: opts.auth ? `Bearer ${opts.auth}` : void 0 },
    url: `https://git.sr.ht/~${parsed.repo}/tree/${parsed.ref}/item${parsed.subdir}`,
    tar: `https://git.sr.ht/~${parsed.repo}/archive/${parsed.ref}.tar.gz`
  };
};
const providers = {
  github,
  gh: github,
  gitlab,
  bitbucket,
  sourcehut
};

const DEFAULT_REGISTRY = "https://raw.githubusercontent.com/unjs/giget/main/templates";
const registryProvider = (registryEndpoint = DEFAULT_REGISTRY) => {
  return async (input) => {
    const start = Date.now();
    const registryURL = `${registryEndpoint}/${input}.json`;
    const res = await fetch$1(registryURL);
    if (res.status >= 400) {
      throw new Error(`Failed to download ${input} template info from ${registryURL}: ${res.status} ${res.statusText}`);
    }
    const info = await res.json();
    if (!info.tar || !info.name) {
      throw new Error(`Invalid template info from ${registryURL}. name or tar fields are missing!`);
    }
    debug(`Fetched ${input} template info from ${registryURL} in ${Date.now() - start}ms`);
    return info;
  };
};

const sourceProtoRe = /^([\w-.]+):/;
async function downloadTemplate(input, opts = {}) {
  opts = defu({
    registry: process.env.GIGET_REGISTRY,
    auth: process.env.GIGET_AUTH
  }, opts);
  const registry = opts.registry !== false ? registryProvider(opts.registry) : null;
  let providerName = opts.provider || (registryProvider ? "registry" : "github");
  let source = input;
  const sourceProvierMatch = input.match(sourceProtoRe);
  if (sourceProvierMatch) {
    providerName = sourceProvierMatch[1];
    source = input.substring(sourceProvierMatch[0].length);
  }
  const provider = opts.providers?.[providerName] || providers[providerName] || registry;
  if (!provider) {
    throw new Error(`Unsupported provider: ${providerName}`);
  }
  const template = await Promise.resolve().then(() => provider(source, { auth: opts.auth })).catch((err) => {
    throw new Error(`Failed to download template from ${providerName}: ${err.message}`);
  });
  template.name = (template.name || "template").replace(/[^a-z0-9-]/gi, "-");
  template.defaultDir = (template.defaultDir || template.name).replace(/[^a-z0-9-]/gi, "-");
  const cwd = resolve(opts.cwd || ".");
  const extractPath = resolve(cwd, opts.dir || template.defaultDir);
  if (opts.forceClean) {
    await rm(extractPath, { recursive: true, force: true });
  }
  if (!opts.force && existsSync(extractPath) && readdirSync(extractPath).length) {
    throw new Error(`Destination ${extractPath} already exists.`);
  }
  await mkdir(extractPath, { recursive: true });
  const tmpDir = resolve(homedir(), ".giget", opts.provider, template.name);
  const tarPath = resolve(tmpDir, (template.version || template.name) + ".tar.gz");
  if (opts.preferOffline && existsSync(tarPath)) {
    opts.offline = true;
  }
  if (!opts.offline) {
    await mkdir(dirname(tarPath), { recursive: true });
    const s2 = Date.now();
    await download(template.tar, tarPath, { headers: template.headers }).catch((err) => {
      if (!existsSync(tarPath)) {
        throw err;
      }
      debug("Download error. Using cached version:", err);
      opts.offline = true;
    });
    debug(`Downloaded ${template.tar} to ${tarPath} in ${Date.now() - s2}ms`);
  }
  if (!existsSync(tarPath)) {
    throw new Error(`Tarball not found: ${tarPath} (offline: ${opts.offline})`);
  }
  const s = Date.now();
  const subdir = template.subdir?.replace(/^\//, "") || "";
  await extract({
    file: tarPath,
    cwd: extractPath,
    onentry(entry) {
      entry.path = entry.path.split("/").splice(1).join("/");
      if (subdir) {
        if (entry.path.startsWith(subdir + "/")) {
          entry.path = entry.path.substring(subdir.length);
        } else {
          entry.path = "";
        }
      }
    }
  });
  debug(`Extracted to ${extractPath} in ${Date.now() - s}ms`);
  return {
    ...template,
    source,
    dir: extractPath
  };
}

export { downloadTemplate as d, registryProvider as r, startShell as s };
